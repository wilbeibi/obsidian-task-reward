/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TaskRewardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableSound: true,
  enableConfetti: true,
  globalMute: false,
  disableConfetti: false,
  soundVolume: 0.3,
  confettiDuration: 800,
  mergeWindowMs: 300,
  throttleMs: 250,
  undoWindowMs: 1e3
};
var RewardSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Task Reward Settings" });
    containerEl.createEl("h3", { text: "Quick Controls" });
    new import_obsidian.Setting(containerEl).setName("Enable sound").setDesc("Play reward sound when completing tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSound).onChange(async (value) => {
      this.plugin.settings.enableSound = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable confetti").setDesc("Show confetti animation when completing tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableConfetti).onChange(async (value) => {
      this.plugin.settings.enableConfetti = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Global mute").setDesc("Quickly disable all sound feedback").addToggle((toggle) => toggle.setValue(this.plugin.settings.globalMute).onChange(async (value) => {
      this.plugin.settings.globalMute = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sound Settings" });
    new import_obsidian.Setting(containerEl).setName("Volume").setDesc("Adjust the volume of reward sound (0-100%)").addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.soundVolume * 100).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.soundVolume = value / 100;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Confetti Settings" });
    new import_obsidian.Setting(containerEl).setName("Animation duration").setDesc("Confetti animation duration (milliseconds)").addSlider((slider) => slider.setLimits(400, 1200, 100).setValue(this.plugin.settings.confettiDuration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.confettiDuration = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Merge window").setDesc("Milliseconds to merge multiple task completions into one feedback").addText((text) => text.setValue(String(this.plugin.settings.mergeWindowMs)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 100 && num <= 1e3) {
        this.plugin.settings.mergeWindowMs = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Throttle interval").setDesc("Minimum interval between feedbacks (milliseconds)").addText((text) => text.setValue(String(this.plugin.settings.throttleMs)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 100 && num <= 1e3) {
        this.plugin.settings.throttleMs = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Undo protection window").setDesc("Milliseconds to prevent duplicate feedback after unchecking and rechecking").addText((text) => text.setValue(String(this.plugin.settings.undoWindowMs)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 500 && num <= 3e3) {
        this.plugin.settings.undoWindowMs = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Test" });
    new import_obsidian.Setting(containerEl).setName("Test single completion").setDesc("Preview feedback for one task completion").addButton((button) => button.setButtonText("Test").onClick(() => {
      this.plugin.soundManager.playRewardSound("light", this.plugin.settings.soundVolume);
      this.plugin.confettiManager.burst({
        intensity: "light",
        particleCount: 15,
        duration: this.plugin.settings.confettiDuration
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Test batch completion").setDesc("Preview feedback for 5 task completions").addButton((button) => button.setButtonText("Test").onClick(() => {
      this.plugin.soundManager.playRewardSound("heavy", this.plugin.settings.soundVolume);
      this.plugin.confettiManager.burst({
        intensity: "heavy",
        particleCount: 50,
        duration: this.plugin.settings.confettiDuration
      });
    }));
    containerEl.createEl("p", {
      text: 'Note: The plugin automatically respects system "reduce motion" preferences.',
      cls: "setting-item-description"
    });
  }
};

// sound.ts
var import_obsidian2 = require("obsidian");
var SoundManager = class {
  constructor(plugin) {
    this.audioBuffer = null;
    this.audioElement = null;
    this.audioContext = null;
    this.objectUrl = null;
    this.useWebAudio = true;
    this.loading = null;
    this.unlockHandler = null;
    this.plugin = plugin;
    this.loading = this.loadSound();
    this.loading.catch((error) => {
      console.warn("Task Reward: Failed to preload sound", error);
    });
    this.unlockHandler = () => this.unlockAudio();
    this.plugin.registerDomEvent(window, "pointerdown", this.unlockHandler);
    this.plugin.registerDomEvent(window, "keydown", this.unlockHandler);
  }
  async loadSound() {
    var _a;
    try {
      const adapter = this.plugin.app.vault.adapter;
      const configDir = (_a = this.plugin.app.vault.configDir) != null ? _a : ".obsidian";
      const basePath = (0, import_obsidian2.normalizePath)(`${configDir}/plugins/${this.plugin.manifest.id}/sound`);
      const candidates = ["reward.m4a", "reward.mp3"];
      for (const file of candidates) {
        const vaultRelativePath = (0, import_obsidian2.normalizePath)(`${basePath}/${file}`);
        let exists = true;
        if (typeof adapter.exists === "function") {
          exists = await adapter.exists(vaultRelativePath);
        }
        if (!exists) {
          continue;
        }
        const resourcePath = typeof adapter.getResourcePath === "function" ? adapter.getResourcePath(vaultRelativePath) : null;
        if (resourcePath) {
          if (await this.tryLoadWithWebAudioFromUrl(resourcePath)) {
            console.log(`Task Reward: Sound loaded via resource URL with Web Audio (${file})`);
            return;
          }
          if (this.tryLoadWithHtmlAudioFromUrl(resourcePath)) {
            console.log(`Task Reward: Sound ready via HTML audio (${file})`);
            return;
          }
        }
        if (typeof adapter.readBinary === "function") {
          try {
            const binary = await adapter.readBinary(vaultRelativePath);
            const arrayBuffer = this.toArrayBuffer(binary);
            if (await this.tryLoadWithWebAudio(arrayBuffer)) {
              console.log(`Task Reward: Sound loaded with Web Audio API (${file})`);
              return;
            }
            if (this.tryLoadWithHtmlAudioFromBuffer(arrayBuffer, file)) {
              console.log(`Task Reward: Sound loaded with HTML5 audio fallback (${file})`);
              return;
            }
          } catch (readError) {
            console.warn(`Task Reward: Failed to read audio asset ${vaultRelativePath}`, readError);
          }
        }
      }
      console.warn("Task Reward: No audio asset found, falling back to synthesized sound.");
    } catch (error) {
      console.warn("Task Reward: Failed to load sound asset, will use synthesized sound.", error);
    } finally {
      this.loading = null;
    }
  }
  playRewardSound(intensity, volume) {
    if (this.loading) {
      this.loading.then(() => {
        this.playRewardSound(intensity, volume);
      }).catch((error) => {
        console.warn("Task Reward: Deferred sound playback failed", error);
        this.playSynthesizedSound(intensity, volume);
      });
      return;
    }
    const volumeMultiplier = intensity === "light" ? 0.8 : intensity === "medium" ? 1 : 1.2;
    const adjustedVolume = Math.min(volume * volumeMultiplier, 1);
    if (this.useWebAudio && this.audioBuffer) {
      this.playWebAudio(intensity, adjustedVolume);
    } else if (this.audioElement) {
      this.playHTML5Audio(intensity, adjustedVolume);
    } else {
      this.playSynthesizedSound(intensity, volume);
    }
  }
  toArrayBuffer(binary) {
    if (binary instanceof ArrayBuffer) {
      return binary.slice(0);
    }
    if (binary instanceof Uint8Array) {
      return binary.buffer.slice(binary.byteOffset, binary.byteOffset + binary.byteLength);
    }
    return new Uint8Array(binary).buffer;
  }
  async tryLoadWithWebAudioFromUrl(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        return false;
      }
      const arrayBuffer = await response.arrayBuffer();
      return this.tryLoadWithWebAudio(arrayBuffer);
    } catch (error) {
      console.warn("Task Reward: Failed to fetch audio asset for Web Audio playback.", error);
      return false;
    }
  }
  async tryLoadWithWebAudio(arrayBuffer) {
    const audioContext = this.ensureAudioContext();
    if (!audioContext) {
      this.useWebAudio = false;
      return false;
    }
    try {
      const decoded = await audioContext.decodeAudioData(arrayBuffer.slice(0));
      this.audioBuffer = decoded;
      this.useWebAudio = true;
      return true;
    } catch (error) {
      console.warn("Task Reward: Audio decoding failed, will try HTML audio fallback.", error);
      this.audioBuffer = null;
      this.useWebAudio = false;
      return false;
    }
  }
  tryLoadWithHtmlAudioFromUrl(url) {
    try {
      this.audioElement = new Audio(url);
      this.audioElement.preload = "auto";
      this.audioElement.crossOrigin = "anonymous";
      this.audioElement.load();
      this.attachHtmlAudioHandlers(this.audioElement);
      this.useWebAudio = false;
      return true;
    } catch (error) {
      console.warn("Task Reward: Failed to initialise HTML audio from URL.", error);
      this.audioElement = null;
      return false;
    }
  }
  tryLoadWithHtmlAudioFromBuffer(arrayBuffer, fileName) {
    try {
      const mimeType = fileName.endsWith(".mp3") ? "audio/mpeg" : "audio/mp4";
      const blob = new Blob([arrayBuffer.slice(0)], { type: mimeType });
      this.objectUrl = URL.createObjectURL(blob);
      this.audioElement = new Audio(this.objectUrl);
      this.audioElement.preload = "auto";
      this.audioElement.crossOrigin = "anonymous";
      this.audioElement.load();
      this.attachHtmlAudioHandlers(this.audioElement);
      this.useWebAudio = false;
      return true;
    } catch (error) {
      console.warn("Task Reward: Failed to initialize HTML audio element.", error);
      this.audioElement = null;
      return false;
    }
  }
  ensureAudioContext() {
    if (this.audioContext)
      return this.audioContext;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor)
      return null;
    try {
      this.audioContext = new AudioContextCtor();
      return this.audioContext;
    } catch (error) {
      console.warn("Task Reward: Failed to create AudioContext.", error);
      this.audioContext = null;
      return null;
    }
  }
  unlockAudio() {
    const context = this.audioContext;
    if (context && context.state === "suspended") {
      context.resume().catch(() => {
      });
    }
    if (this.audioElement && this.audioElement.paused) {
      const previousVolume = this.audioElement.volume;
      this.audioElement.volume = 0;
      this.audioElement.play().then(() => {
        var _a;
        (_a = this.audioElement) == null ? void 0 : _a.pause();
        if (this.audioElement) {
          this.audioElement.currentTime = 0;
          this.audioElement.volume = previousVolume;
        }
      }).catch(() => {
        if (this.audioElement) {
          this.audioElement.volume = previousVolume;
        }
      });
    }
    if (context && context.state === "running" && (!this.audioElement || this.audioElement.currentTime === 0)) {
      if (this.unlockHandler) {
        window.removeEventListener("pointerdown", this.unlockHandler);
        window.removeEventListener("keydown", this.unlockHandler);
        this.unlockHandler = null;
      }
    }
  }
  playWebAudio(intensity, volume) {
    if (!this.audioBuffer)
      return;
    const audioContext = this.ensureAudioContext();
    if (!audioContext) {
      this.useWebAudio = false;
      this.playHTML5Audio(intensity, volume);
      return;
    }
    const startPlayback = () => {
      try {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        source.buffer = this.audioBuffer;
        gainNode.gain.value = volume;
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start();
      } catch (error) {
        console.warn("Task Reward: Failed to play Web Audio:", error);
        this.playHTML5Audio(intensity, volume);
      }
    };
    if (audioContext.state === "suspended") {
      audioContext.resume().then(startPlayback).catch((error) => {
        console.warn("Task Reward: Unable to resume AudioContext, falling back to HTML audio.", error);
        this.useWebAudio = false;
        this.playHTML5Audio(intensity, volume);
      });
    } else {
      startPlayback();
    }
  }
  playHTML5Audio(intensity, volume) {
    if (!this.audioElement)
      return;
    try {
      this.audioElement.pause();
      this.audioElement.currentTime = 0;
      this.audioElement.volume = volume;
      const promise = this.audioElement.play();
      if (promise && typeof promise.catch === "function") {
        promise.catch((error) => {
          console.warn("Task Reward: Failed to play HTML5 audio:", error);
          this.playSynthesizedSound(intensity, volume);
        });
      }
    } catch (error) {
      console.warn("Task Reward: Failed to play HTML5 audio:", error);
      this.playSynthesizedSound(intensity, volume);
    }
  }
  attachHtmlAudioHandlers(element) {
    element.addEventListener("error", () => {
      const mediaError = element.error;
      if (mediaError) {
        console.warn("Task Reward: Audio element reported error code", mediaError.code);
      }
    });
  }
  playSynthesizedSound(intensity, volume) {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const audioContext = new AudioContext();
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
      const now = audioContext.currentTime;
      const layers = intensity === "light" ? 1 : intensity === "medium" ? 2 : 3;
      this.synthesizeTone(audioContext, now, volume, layers);
    } catch (error) {
      console.warn("Task Reward: Failed to play synthesized sound:", error);
    }
  }
  synthesizeTone(audioContext, startTime, volume, layers) {
    const gainNode = audioContext.createGain();
    gainNode.connect(audioContext.destination);
    const frequencies = [
      [880, 1100],
      // A5, C#6
      [660, 880],
      // E5, A5
      [440, 660]
      // A4, E5
    ];
    for (let i = 0; i < Math.min(layers, frequencies.length); i++) {
      const delay = i * 0.03;
      frequencies[i].forEach((freq, idx) => {
        const oscillator = audioContext.createOscillator();
        const layerGain = audioContext.createGain();
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(freq, startTime + delay);
        const layerVolume = volume * 0.15 * (1 - i * 0.2);
        layerGain.gain.setValueAtTime(0, startTime + delay);
        layerGain.gain.linearRampToValueAtTime(layerVolume, startTime + delay + 0.01);
        layerGain.gain.exponentialRampToValueAtTime(1e-3, startTime + delay + 0.15 + idx * 0.05);
        oscillator.connect(layerGain);
        layerGain.connect(gainNode);
        oscillator.start(startTime + delay);
        oscillator.stop(startTime + delay + 0.2);
      });
    }
  }
  cleanup() {
    this.audioBuffer = null;
    if (this.audioContext) {
      if (typeof this.audioContext.close === "function") {
        this.audioContext.close().catch(() => {
        });
      }
      this.audioContext = null;
    }
    if (this.audioElement) {
      this.audioElement.pause();
      this.audioElement.src = "";
      this.audioElement = null;
    }
    if (this.objectUrl) {
      URL.revokeObjectURL(this.objectUrl);
      this.objectUrl = null;
    }
    if (this.unlockHandler) {
      window.removeEventListener("pointerdown", this.unlockHandler);
      window.removeEventListener("keydown", this.unlockHandler);
      this.unlockHandler = null;
    }
  }
};

// confetti.ts
var ConfettiManager = class {
  constructor(plugin) {
    this.canvas = null;
    this.ctx = null;
    this.particles = [];
    this.animationFrame = null;
    this.colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FFA07A", "#98D8C8", "#F7DC6F"];
    this.resizeHandler = null;
    this.logicalWidth = 0;
    this.logicalHeight = 0;
    this.plugin = plugin;
    this.setupCanvas();
  }
  setupCanvas() {
    if (this.canvas)
      return;
    this.canvas = document.createElement("canvas");
    this.canvas.style.position = "fixed";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this.canvas.style.pointerEvents = "none";
    this.canvas.style.zIndex = "9999";
    this.canvas.style.opacity = "1";
    this.ctx = this.canvas.getContext("2d");
    this.resizeHandler = () => this.resizeCanvas();
    this.resizeCanvas();
    if (this.resizeHandler) {
      this.plugin.registerDomEvent(window, "resize", this.resizeHandler);
    }
  }
  resizeCanvas() {
    if (!this.canvas)
      return;
    const dpr = window.devicePixelRatio || 1;
    this.logicalWidth = window.innerWidth;
    this.logicalHeight = window.innerHeight;
    this.canvas.style.width = `${this.logicalWidth}px`;
    this.canvas.style.height = `${this.logicalHeight}px`;
    this.canvas.width = Math.floor(this.logicalWidth * dpr);
    this.canvas.height = Math.floor(this.logicalHeight * dpr);
    if (this.ctx) {
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }
  burst(config) {
    var _a, _b, _c, _d;
    this.ensureCanvas();
    this.particles = [];
    const width = this.logicalWidth || window.innerWidth;
    const height = this.logicalHeight || window.innerHeight;
    const originX = this.clamp((_b = (_a = config.origin) == null ? void 0 : _a.x) != null ? _b : width / 2, 40, Math.max(40, width - 40));
    const originY = this.clamp((_d = (_c = config.origin) == null ? void 0 : _c.y) != null ? _d : height * 0.25, 40, Math.max(40, height - 40));
    const spreadX = Math.max(width * 0.25, 160);
    const spreadY = Math.max(height * 0.15, 80);
    for (let i = 0; i < config.particleCount; i++) {
      const spawnX = originX + (Math.random() - 0.5) * spreadX;
      const spawnY = originY + (Math.random() - 0.5) * spreadY * 0.3;
      this.particles.push({
        x: spawnX,
        y: spawnY,
        vx: (Math.random() - 0.5) * 6,
        vy: -(Math.random() * 3 + 2),
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
        color: this.colors[Math.floor(Math.random() * this.colors.length)],
        size: Math.random() * 6 + 4,
        life: 1,
        maxLife: config.duration
      });
    }
    if (this.canvas && !this.canvas.parentElement) {
      document.body.appendChild(this.canvas);
    }
    this.startAnimation();
  }
  startAnimation() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    const startTime = performance.now();
    const animate = (currentTime) => {
      if (!this.ctx || !this.canvas)
        return;
      const elapsed = currentTime - startTime;
      this.ctx.clearRect(0, 0, this.logicalWidth, this.logicalHeight);
      this.particles = this.particles.filter((particle) => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.18;
        particle.rotation += particle.rotationSpeed;
        particle.life = 1 - elapsed / particle.maxLife;
        if (particle.life <= 0)
          return false;
        this.ctx.save();
        this.ctx.translate(particle.x, particle.y);
        this.ctx.rotate(particle.rotation * Math.PI / 180);
        this.ctx.globalAlpha = particle.life * 0.9;
        this.ctx.fillStyle = particle.color;
        if (Math.random() > 0.5) {
          this.ctx.fillRect(
            -particle.size / 2,
            -particle.size / 3,
            particle.size,
            particle.size / 1.5
          );
        } else {
          this.ctx.beginPath();
          this.ctx.arc(0, 0, particle.size / 2, 0, Math.PI * 2);
          this.ctx.fill();
        }
        this.ctx.restore();
        return true;
      });
      if (this.particles.length > 0) {
        this.animationFrame = requestAnimationFrame(animate);
      } else {
        this.stopAnimation();
      }
    };
    this.animationFrame = requestAnimationFrame(animate);
  }
  stopAnimation() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    if (this.canvas && this.canvas.parentElement) {
      this.canvas.parentElement.removeChild(this.canvas);
    }
    if (this.ctx && this.canvas) {
      this.ctx.clearRect(0, 0, this.logicalWidth, this.logicalHeight);
    }
  }
  cleanup() {
    this.stopAnimation();
    if (this.canvas && this.canvas.parentElement) {
      this.canvas.parentElement.removeChild(this.canvas);
    }
    this.canvas = null;
    this.ctx = null;
    this.particles = [];
    this.logicalWidth = 0;
    this.logicalHeight = 0;
  }
  ensureCanvas() {
    if (!this.canvas) {
      this.setupCanvas();
    }
    this.resizeCanvas();
  }
  clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
};

// main.ts
var TaskRewardPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    // Event merging and throttling
    this.taskEventQueue = [];
    this.mergeTimer = null;
    this.lastFeedbackTime = 0;
    this.undoProtection = /* @__PURE__ */ new Map();
    // key: file:line, value: timestamp
    this.taskStates = /* @__PURE__ */ new Map();
    this.recentTaskCoordinates = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.soundManager = new SoundManager(this);
    this.confettiManager = new ConfettiManager(this);
    this.registerEvent(
      this.app.metadataCache.on("changed", (file, _data, cache) => {
        if (file instanceof import_obsidian3.TFile && file.extension === "md") {
          this.handleTaskMetadataChange(file, cache);
        }
      })
    );
    this.addSettingTab(new RewardSettingTab(this.app, this));
    this.registerDomEvent(document, "change", (event) => {
      var _a, _b;
      const target = event.target;
      if (!target || !(target instanceof HTMLInputElement))
        return;
      if (!target.classList.contains("task-list-item-checkbox"))
        return;
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      const lineAttr = (_b = target.dataset.line) != null ? _b : (_a = target.closest("[data-line]")) == null ? void 0 : _a.getAttribute("data-line");
      if (!lineAttr)
        return;
      const line = parseInt(lineAttr, 10);
      if (Number.isNaN(line))
        return;
      const rect = target.getBoundingClientRect();
      const coords = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
      const key = `${file.path}:${line}`;
      this.recentTaskCoordinates.set(key, {
        coords,
        timestamp: Date.now()
      });
    });
    console.log("Task Reward Plugin loaded");
  }
  onunload() {
    this.soundManager.cleanup();
    this.confettiManager.cleanup();
    if (this.mergeTimer) {
      window.clearTimeout(this.mergeTimer);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleTaskMetadataChange(file, cache) {
    var _a, _b, _c;
    if (!cache) {
      this.taskStates.delete(file.path);
      return;
    }
    const tasks = ((_a = cache.listItems) != null ? _a : []).filter((item) => item.task !== void 0);
    const currentStates = /* @__PURE__ */ new Map();
    if (!this.taskStates.has(file.path)) {
      for (const task of tasks) {
        currentStates.set(task.position.start.line, this.isChecked(task));
      }
      this.taskStates.set(file.path, currentStates);
      return;
    }
    const previousStates = (_b = this.taskStates.get(file.path)) != null ? _b : /* @__PURE__ */ new Map();
    const now = Date.now();
    for (const task of tasks) {
      const line = task.position.start.line;
      const isChecked = this.isChecked(task);
      const wasChecked = (_c = previousStates.get(line)) != null ? _c : false;
      const taskKey = `${file.path}:${line}`;
      currentStates.set(line, isChecked);
      if (!wasChecked && isChecked) {
        const lastUndoTime = this.undoProtection.get(taskKey);
        if (lastUndoTime && now - lastUndoTime < this.settings.undoWindowMs) {
          continue;
        }
        this.cleanupUndoProtection(now);
        this.queueTaskEvent({
          file,
          line,
          checked: true,
          timestamp: now
        });
      } else if (wasChecked && !isChecked) {
        this.undoProtection.set(taskKey, now);
      }
    }
    this.taskStates.set(file.path, currentStates);
  }
  isChecked(task) {
    if (typeof task.task !== "string") {
      return false;
    }
    const normalized = task.task.trim().toLowerCase();
    return normalized === "x" || normalized === "check" || normalized === "checked";
  }
  cleanupUndoProtection(now) {
    if (this.undoProtection.size <= 100)
      return;
    for (const [key, time] of this.undoProtection.entries()) {
      if (now - time > this.settings.undoWindowMs * 2) {
        this.undoProtection.delete(key);
      }
    }
  }
  queueTaskEvent(event) {
    var _a;
    const key = `${event.file.path}:${event.line}`;
    let cachedCoords = null;
    const recent = this.recentTaskCoordinates.get(key);
    const now = Date.now();
    if (recent && now - recent.timestamp < 1500) {
      cachedCoords = recent.coords;
    }
    this.recentTaskCoordinates.delete(key);
    const enrichedEvent = {
      ...event,
      coords: (_a = cachedCoords != null ? cachedCoords : event.coords) != null ? _a : this.computeTaskCoordinates(event.file, event.line)
    };
    this.taskEventQueue.push(enrichedEvent);
    if (this.mergeTimer) {
      window.clearTimeout(this.mergeTimer);
    }
    this.mergeTimer = window.setTimeout(() => {
      this.processMergedEvents();
    }, this.settings.mergeWindowMs);
  }
  processMergedEvents() {
    const now = Date.now();
    const events = this.taskEventQueue.slice();
    const count = events.length;
    if (now - this.lastFeedbackTime < this.settings.throttleMs) {
      this.taskEventQueue = [];
      this.mergeTimer = null;
      return;
    }
    if (count === 0) {
      this.mergeTimer = null;
      return;
    }
    const profile = this.getFeedbackProfile(count);
    this.triggerFeedback(profile, events);
    this.taskEventQueue = [];
    this.mergeTimer = null;
    this.lastFeedbackTime = now;
  }
  getFeedbackProfile(count) {
    const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const muted = this.settings.globalMute;
    const intensity = "heavy";
    return {
      sound: muted ? null : {
        intensity,
        volume: this.settings.soundVolume
      },
      confetti: reducedMotion || this.settings.disableConfetti ? null : {
        intensity,
        particleCount: this.getParticleCount(intensity),
        duration: this.settings.confettiDuration
      }
    };
  }
  getParticleCount(_intensity) {
    return 150;
  }
  triggerFeedback(profile, events) {
    const startTime = performance.now();
    if (profile.sound && this.settings.enableSound) {
      this.soundManager.playRewardSound(profile.sound.intensity, profile.sound.volume);
    }
    if (profile.confetti && this.settings.enableConfetti) {
      const origin = this.getConfettiOrigin(events);
      this.confettiManager.burst({
        ...profile.confetti,
        origin: origin != null ? origin : void 0
      });
    }
    const elapsed = performance.now() - startTime;
    if (elapsed > 200) {
      console.warn(`Task Reward: Feedback delay: ${elapsed.toFixed(1)}ms (target: \u2264200ms)`);
    }
  }
  getConfettiOrigin(events) {
    const coords = events.map((event) => {
      if (!event.coords) {
        event.coords = this.computeTaskCoordinates(event.file, event.line);
      }
      return event.coords;
    }).filter((value) => !!value);
    if (coords.length === 0) {
      return null;
    }
    const sum = coords.reduce((acc, coord) => {
      acc.x += coord.x;
      acc.y += coord.y;
      return acc;
    }, { x: 0, y: 0 });
    return {
      x: sum.x / coords.length,
      y: sum.y / coords.length
    };
  }
  computeTaskCoordinates(file, line) {
    var _a, _b, _c, _d, _e, _f, _g;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view || view.file !== file) {
      return null;
    }
    try {
      const mode = (_a = view.getMode) == null ? void 0 : _a.call(view);
      const editor = view.editor;
      const cm = editor == null ? void 0 : editor.cm;
      if ((!mode || mode === "source" || mode === "source-both") && (cm == null ? void 0 : cm.state)) {
        const doc = cm.state.doc;
        const lineNumber = Math.min(Math.max(0, line), doc.lines - 1);
        const docLine = doc.line(lineNumber + 1);
        const coords = (_b = cm.coordsAtPos) == null ? void 0 : _b.call(cm, docLine.from);
        if (coords) {
          return {
            x: coords.left + (coords.right - coords.left) / 2,
            y: coords.top + (coords.bottom - coords.top) / 2
          };
        }
        const fallbackCoords = (_c = cm.coordsAtPos) == null ? void 0 : _c.call(cm, docLine.to);
        if (fallbackCoords) {
          return {
            x: fallbackCoords.left + (fallbackCoords.right - fallbackCoords.left) / 2,
            y: fallbackCoords.top + (fallbackCoords.bottom - fallbackCoords.top) / 2
          };
        }
      }
      const previewContainer = (_g = (_f = (_e = (_d = view.previewMode) == null ? void 0 : _d.renderer) == null ? void 0 : _e.view) == null ? void 0 : _f.containerEl) != null ? _g : null;
      if (previewContainer) {
        const lineEl = previewContainer.querySelector(`[data-line="${line}"]`);
        if (lineEl) {
          const rect = lineEl.getBoundingClientRect();
          return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };
        }
      }
    } catch (error) {
      console.warn("Task Reward: Failed to compute task coordinates", error);
    }
    return null;
  }
};
